"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createArchwayQueryClient = void 0;
const cosmwasm_stargate_1 = require("@cosmjs/cosmwasm-stargate");
const stargate_1 = require("@cosmjs/stargate");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const modules_1 = require("./modules");
class ArchwayQueryClientImpl {
    constructor(tmClient) {
        if (tmClient) {
            this.queryClient = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, cosmwasm_stargate_1.setupWasmExtension, modules_1.setupRewardsExtension, stargate_1.setupTxExtension);
        }
    }
    getQueryClient() {
        return this.queryClient;
    }
    forceGetQueryClient() {
        if (!this.getQueryClient()) {
            throw new Error('Query client not available. You cannot use online functionality in offline mode.');
        }
        return this.queryClient;
    }
    async getBlockRewardsTracking() {
        const client = this.forceGetQueryClient();
        const { block: { txRewards: txRewardsResponse, inflationRewards } } = await client.rewards.blockRewardsTracking();
        const txRewards = txRewardsResponse.map(txReward => {
            return {
                txId: txReward.txId.toNumber(),
                height: txReward.height.toNumber(),
                feeRewards: txReward.feeRewards,
            };
        });
        return {
            inflationRewards: {
                height: inflationRewards.height.toNumber(),
                inflationRewards: inflationRewards.inflationRewards,
                maxGas: inflationRewards.maxGas.toNumber(),
            },
            txRewards,
        };
    }
    async getContractMetadata(contractAddress) {
        const client = this.forceGetQueryClient();
        const { metadata: { ownerAddress, rewardsAddress } } = await client.rewards.contractMetadata(contractAddress);
        return {
            contractAddress,
            ownerAddress,
            rewardsAddress
        };
    }
    async getContractPremium(contractAddress) {
        const client = this.forceGetQueryClient();
        try {
            const { flatFeeAmount } = await client.rewards.flatFee(contractAddress);
            return {
                contractAddress,
                flatFee: flatFeeAmount,
            };
        }
        catch (e) {
            return {
                contractAddress,
            };
        }
    }
    async getEstimateTxFees(gasLimit = 1, contractAddress) {
        const client = this.forceGetQueryClient();
        const { estimatedFee, gasUnitPrice: { amount: gasPriceAmount, denom: gasPriceDenom } } = await client.rewards.estimateTxFees(gasLimit, contractAddress !== null && contractAddress !== void 0 ? contractAddress : '');
        // The RPC queries do not include the decimal precision fot types.Dec,
        // so we need to manually decode the gas amount from the proto, as suggested in
        // https://github.com/osmosis-labs/telescope/issues/247#issuecomment-1292407464
        // See also: https://github.com/cosmos/cosmos-sdk/issues/10863
        const gasUnitPriceAmount = (0, stargate_1.decodeCosmosSdkDecFromProto)(gasPriceAmount);
        const gasUnitPrice = new stargate_1.GasPrice(gasUnitPriceAmount, gasPriceDenom);
        return {
            contractAddress,
            gasUnitPrice,
            estimatedFee: {
                amount: estimatedFee,
                gas: gasLimit.toString(),
            }
        };
    }
    async getOutstandingRewards(rewardsAddress) {
        const client = this.forceGetQueryClient();
        const { totalRewards, recordsNum } = await client.rewards.outstandingRewards(rewardsAddress);
        return {
            rewardsAddress,
            totalRewards,
            totalRecords: recordsNum.toNumber(),
        };
    }
    async getRewardsPool() {
        const client = this.forceGetQueryClient();
        const { undistributedFunds, treasuryFunds } = await client.rewards.rewardsPool();
        return {
            undistributedFunds,
            treasuryFunds
        };
    }
    async getAllRewardsRecords(rewardsAddress) {
        const client = this.forceGetQueryClient();
        const allRewardsRecords = new Array();
        let startAtKey = undefined;
        do {
            /* eslint no-await-in-loop: "off" */
            const { records, pagination } = await client.rewards.rewardsRecords(rewardsAddress, startAtKey);
            const rewardsRecords = records.map(record => {
                const calculatedTime = (0, tendermint_rpc_1.fromSeconds)(record.calculatedTime.seconds.toNumber(), record.calculatedTime.nanos);
                return {
                    id: record.id.toNumber(),
                    rewardsAddress: record.rewardsAddress,
                    calculatedHeight: record.calculatedHeight.toNumber(),
                    calculatedTime: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(calculatedTime),
                    rewards: record.rewards,
                };
            });
            allRewardsRecords.push(...rewardsRecords);
            startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;
        } while ((startAtKey === null || startAtKey === void 0 ? void 0 : startAtKey.length) !== 0);
        return allRewardsRecords;
    }
}
/**
 * Created a facade for querying archway modules using the
 * {@link QueryClient} extended with the {@link RewardsExtension}.
 *
 * @param tmClient - A Tendermint client for a given endpoint.
 * @returns A new {@link IArchwayQueryClient} implementation.
 */
function createArchwayQueryClient(tmClient) {
    return new ArchwayQueryClientImpl(tmClient);
}
exports.createArchwayQueryClient = createArchwayQueryClient;
//# sourceMappingURL=queryclient.js.map